{"version":3,"sources":["../../lib/cluster/worker.ts"],"names":["globalSandbox","Worker","constructor","message","initialize","onInitialize","onExecute","sandboxOptions","create","wait","execute","queue","async","worker","Sandbox","sandbox","initialized","error","Promise","resolve","reject","check","setImmediate","code","timeout","globals","context","result","JSON","parse","output","name","stack","process","send","setInterval","connected","exit","on","push"],"mappings":"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","sourcesContent":["import Sandbox, { Options } from '../server/sandbox';\nimport async from 'async';\nimport assert from 'assert';\n\nlet globalSandbox = null;\n\ninterface Message {\n  initialize: boolean;\n  require?: string;\n  template?: string;\n  code?: string;\n  globals?: string;\n  context?: string;\n  timeout: number;\n}\n\nclass Worker {\n  queue: async.AsyncQueue<Message>;\n\n  sandboxOptions: Options;\n\n  sandbox: Sandbox;\n\n  initialized: boolean;\n\n  error: any;\n\n  constructor() {\n    this.queue = async.queue(this.worker, 1);\n  }\n\n  create() {\n    if (!globalSandbox) {\n      globalSandbox = new Sandbox(this.sandboxOptions);\n    }\n\n    this.sandbox = globalSandbox;\n    this.initialized = false;\n\n    return this.initialize();\n  }\n\n  async initialize() {\n    assert(!this.initialized);\n\n    try {\n      const { error } = await this.sandbox.initialize();\n\n      if (error) {\n        this.error = error;\n      }\n    } catch (error) {\n      this.error = error;\n    }\n\n    this.initialized = true;\n  }\n\n  wait() {\n    return new Promise((resolve, reject) => {\n      const check = () => {\n        if (this.initialized) {\n          resolve();\n        } else {\n          setImmediate(check);\n        }\n      };\n\n      check();\n    });\n  }\n\n  async execute({ code, timeout, globals, context }: Message) {\n    assert(this.initialized);\n\n    let result;\n\n    if (!this.error) {\n      result = await this.sandbox.execute({\n        code,\n        timeout,\n        globals: JSON.parse(globals),\n        context: JSON.parse(context)\n      });\n    } else {\n      result = { error: this.error, output: [] };\n    }\n\n    // convert native error objects into an object that can be serialized\n    if (result.error) {\n      result.error = {\n        name: result.error.name,\n        message: result.error.message,\n        stack: result.error.stack,\n        ...result.error\n      };\n    }\n\n    process.send(result);\n\n    // start creating the next sandbox *after* posting the completion message. This operation happens with coordination from\n    // the calling process, but that's OK because we wait for it's initialization.\n    setImmediate(() => {\n      this.create();\n    });\n  }\n\n  worker = async (message: Message) => {\n    if (message.initialize) {\n      await this.onInitialize(message);\n    } else {\n      await this.onExecute(message);\n    }\n  };\n\n  onInitialize = async (message: Message) => {\n    this.sandboxOptions = message;\n\n    await this.create();\n  };\n\n  onExecute = async (message: Message) => {\n    await this.wait();\n\n    await this.execute(message);\n  };\n}\n\nconst worker = new Worker();\n\n// heartbeat the parent process to make sure this worker process never gets orphaned\n// if the parent process is killed with SIGKILL, the atExit() handler never runs, which\n// leaves this process around forever.\nsetInterval(() => {\n  if (!process.connected) {\n    process.exit();\n  }\n}, 5000);\n\nprocess.on('message', (message) => {\n  worker.queue.push(message);\n});\n"],"file":"worker.js"}