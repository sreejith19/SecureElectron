{"version":3,"sources":["../../lib/server/socket.ts"],"names":["tryParseJSON","value","JSON","parse","ex","Socket","constructor","socket","sandbox","data","message","id","readInt32BE","length","json","toString","Buffer","byteLength","callback","args","isConnected","write","result","string","stringify","undefined","buffer","alloc","writeInt32BE","respond","fail","error","name","stack","Error","dispatch","console","resume","closed","worker","on","handleData","handleEnd","handleClose","handleError","handleDrain","shutdown","end","unref"],"mappings":"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","sourcesContent":["import net from 'net';\nimport { ChildProcess } from 'child_process';\nimport Sandbox from './sandbox';\n\nfunction tryParseJSON(value) {\n  try {\n    return JSON.parse(value);\n  } catch (ex) {\n    return null;\n  }\n}\n\ninterface Message {\n  id: number;\n  length: number;\n  json: string;\n}\n\nexport default class Socket {\n  sandbox: Sandbox;\n\n  worker: ChildProcess;\n\n  socket: net.Socket;\n\n  closed: boolean;\n\n  message: Message;\n\n  constructor(socket, sandbox) {\n    this.sandbox = sandbox;\n    this.worker = sandbox.worker;\n    this.socket = socket;\n    this.socket.on('data', this.handleData);\n    this.socket.on('end', this.handleEnd);\n    this.socket.on('close', this.handleClose);\n    this.socket.on('error', this.handleError);\n    this.socket.on('drain', this.handleDrain);\n  }\n\n  shutdown() {\n    if (this.socket) {\n      this.closed = true;\n      this.socket.end();\n      this.socket.unref();\n    }\n  }\n\n  get isConnected() {\n    // make sure the current sandbox worker is the worker we started with. The worker might've\n    // been replaced by the time this is invoked.\n    return !this.closed && this.worker === this.sandbox.worker;\n  }\n\n  handleData = (data) => {\n    if (!this.message) {\n      this.message = {\n        id: data.readInt32BE(0),\n        length: data.readInt32BE(4),\n        json: data.toString('utf8', 8)\n      };\n    } else {\n      this.message.json += data.toString('utf8');\n    }\n\n    if (Buffer.byteLength(this.message.json) === this.message.length) {\n      const { id, json } = this.message;\n\n      this.message = null;\n\n      const message = tryParseJSON(json);\n\n      const callback = id > 0 && ((...args) => {\n        if (this.isConnected) {\n          this.sandbox.callback(id, args);\n        }\n      });\n\n      const write = (result) => {\n        const string = JSON.stringify({ id, result: result || { value: undefined } });\n        const length = Buffer.byteLength(string, 'utf8');\n        const buffer = Buffer.alloc(length + 4);\n\n        buffer.writeInt32BE(length);\n        buffer.write(string, 4);\n\n        if (this.isConnected) {\n          this.socket.write(buffer);\n        }\n      };\n\n      const respond = (value) => {\n        write({ value });\n      };\n\n      const fail = (error) => {\n        write({\n          error: {\n            name: error.name,\n            message: error.message,\n            stack: error.stack\n          }\n        });\n      };\n\n      try {\n        if (message == null) {\n          throw new Error('invalid dispatch');\n        }\n\n        this.sandbox.dispatch(message, { fail, respond, callback });\n      } catch (ex) {\n        fail(ex);\n      }\n    }\n  };\n\n  handleError = (error) => {\n    console.error('socket error', error);\n  };\n\n  handleDrain = () => {\n    this.socket.resume();\n  };\n\n  handleClose = () => {\n    this.closed = true;\n  };\n\n  handleEnd = () => {\n    this.closed = true;\n  };\n}\n"],"file":"socket.js"}